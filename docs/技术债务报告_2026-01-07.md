# 技术债务报告

> **生成时间**: 2026年1月7日
> **检查范围**: 前端（小程序端 + 管理后台）+ 后端
> **检查依据**: 代码质量、架构设计、性能、安全、可维护性、测试覆盖
> **检查人**: Claude Code

---

## 执行摘要

### 整体评估

| 维度 | 评分 | 状态 | 说明 |
|------|------|------|------|
| 代码结构与架构 | ⭐⭐⭐⭐ | 良好 | 分层清晰，但存在部分重复代码 |
| TypeScript 类型安全 | ⭐⭐⭐ | 中等 | 大量使用 any，类型定义不完整 |
| 性能优化 | ⭐⭐⭐ | 中等 | 缺少性能优化，部分组件重复渲染 |
| 可维护性 | ⭐⭐⭐⭐ | 良好 | 注释较少，但代码可读性较好 |
| 安全性 | ⭐⭐⭐⭐ | 良好 | 无明显安全漏洞，输入校验完善 |
| 测试覆盖 | ⭐⭐ | 差 | 测试覆盖率极低，仅有健康检查测试 |

### 技术债务优先级分布

```
P0 (紧急): 3 项 - 需立即修复
P1 (高优): 8 项 - 需尽快修复
P2 (中优): 12 项 - 建议修复
P3 (低优): 6 项 - 可延后修复
```

---

## 1. 代码结构与架构问题

### 1.1 组件复用性问题

#### P2: 活动卡片组件重复定义

**问题描述**:
- `/frontend/app/src/pages/activities/components/ActivityCard.tsx` (小程序端)
- `/frontend/admin/src/components/ActivityCard.tsx` (管理后台)

两个文件实现了相似功能，但未复用代码。

**影响范围**: 维护成本 ↑，代码一致性 ↓

**建议方案**:
```typescript
// 抽取为共享组件
// packages/shared/components/ActivityCard.tsx
export interface ActivityCardProps {
  activity: Activity
  mode: 'user' | 'admin'
  onAction?: (action: string) => void
}

export const ActivityCard: React.FC<ActivityCardProps> = ({ activity, mode, onAction }) => {
  // 共享逻辑
  if (mode === 'admin') {
    return <AdminActivityCard activity={activity} onAction={onAction} />
  }
  return <UserActivityCard activity={activity} />
}
```

**工作量**: 4 小时

---

#### P2: 表单字段渲染器存在重复逻辑

**问题描述**:
`/frontend/app/src/pages/signup/components/FormFieldRenderer.tsx` 中的字段渲染逻辑与 `/frontend/admin/src/pages/FormDesigner.tsx` 中的字段类型转换逻辑存在重复。

**影响范围**: 字段类型变更需同步修改多处

**建议方案**:
```typescript
// packages/shared/utils/formFieldMapper.ts
export class FormFieldMapper {
  static toFRSchema(fields: FieldItem[]): any { /* ... */ }
  static fromFRSchema(schema: any): FieldItem[] { /* ... */ }
  static renderField(field: FieldItem, value: any, onChange: Function): JSX.Element { /* ... */ }
}
```

**工作量**: 6 小时

---

### 1.2 代码分层问题

#### P3: 业务逻辑与UI组件耦合

**问题描述**:
`/frontend/app/src/pages/signup/index.tsx` (430行) 中包含了大量业务逻辑：
- 表单校验逻辑 (83-119行)
- 同行人员管理逻辑 (262-296行)
- 退出逻辑检查 (200-228行)

**影响范围**: 组件复杂度 ↑，测试难度 ↑

**建议方案**:
```typescript
// hooks/useSignupForm.ts
export const useSignupForm = (activityId: number) => {
  const [formData, setFormData] = useState(DEFAULT_FORM_DATA)
  const [currentStep, setCurrentStep] = useState(0)

  const validateStep = useCallback(() => { /* ... */ }, [])
  const handleNext = useCallback(() => { /* ... */ }, [])
  const handleSubmit = useCallback(() => { /* ... */ }, [])

  return { formData, currentStep, validateStep, handleNext, handleSubmit }
}

// 组件仅负责UI渲染
const SignupPage = () => {
  const { formData, currentStep, handleNext, ... } = useSignupForm(activityId)
  return <View>...</View>
}
```

**工作量**: 8 小时

---

### 1.3 模块耦合度问题

#### P2: 服务层依赖过多

**问题描述**:
`/backend/app/services/signups.py` 中 `SignupService` 依赖了 5 个不同的服务：
- `NotificationService`
- `AuditLogService`
- `BadgeService`
- `BadgeRuleService`
- `SignupRepository`

**影响范围**: 单元测试困难，修改影响范围大

**建议方案**:
```python
# 使用依赖注入 + 接口抽象
class SignupService:
    def __init__(
        self,
        session: Session,
        notification_service: Optional[INotificationService] = None,
        audit_service: Optional[IAuditService] = None,
        badge_service: Optional[IBadgeService] = None,
    ):
        self.repo = SignupRepository(session)
        self.notifications = notification_service or NotificationService(session)
        self.audit = audit_service or AuditLogService(session)
        self.badges = badge_service or BadgeService(session)
```

**工作量**: 12 小时

---

## 2. TypeScript 类型安全问题

### 2.1 `any` 类型滥用

#### P1: 大量使用 `any` 类型

**统计数据**:
```
.ts 文件: 13 处 any
.tsx 文件: 137 处 any
总计: 150+ 处 any
```

**典型案例**:

**案例1**: `/frontend/app/src/pages/signup/index.tsx:67`
```typescript
// ❌ 不良实践
const detail = await fetchActivityDetail(activityId) as any
setActivity({
  id: detail.id,
  title: detail.title,
  location: detail.location,
  // ...
})

// ✅ 推荐做法
interface ActivityDetailResponse {
  id: number
  title: string
  location: string
  location_name: string
  start_time: string
  end_time: string
}

const detail = await fetchActivityDetail(activityId) as ActivityDetailResponse
```

**案例2**: `/frontend/app/src/pages/signup/index.tsx:184`
```typescript
// ❌ 不良实践
} catch (error: any) {
  const errorMessage = error?.response?.data?.message || error?.message || '提交失败，请重试'
}

// ✅ 推荐做法
interface ApiError {
  response?: {
    data?: {
      message?: string
    }
  }
  message?: string
}

} catch (error: unknown) {
  const apiError = error as ApiError
  const errorMessage = apiError?.response?.data?.message || apiError?.message || '提交失败，请重试'
}
```

**案例3**: `/frontend/admin/src/pages/FormDesigner.tsx:117-137`
```typescript
// ❌ 不良实践
const [activities, setActivities] = useState<any[]>([])

// ✅ 推荐做法
interface Activity {
  id: number
  title: string
  form_fields?: FormField[]
}

const [activities, setActivities] = useState<Activity[]>([])
```

**影响范围**:
- 丧失类型检查能力
- IDE 智能提示失效
- 运行时类型错误增加

**建议方案**:
1. 立即修复：为所有 API 响应定义完整的类型接口
2. 渐进式修复：从核心模块开始，逐步替换 `any` 为具体类型
3. 启用严格模式：在 `tsconfig.json` 中启用 `noImplicitAny`

```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true
  }
}
```

**工作量**: 24 小时

---

### 2.2 类型定义不完整

#### P1: 缺少共享类型定义库

**问题描述**:
相同的数据结构在多个文件中重复定义，导致不一致：

```typescript
// frontend/app/src/pages/signup/types.ts
export interface ActivityInfo {
  id: number
  title: string
  location: string
  location_name?: string
  start_time: string
  end_time: string
}

// frontend/app/src/pages/activity-detail/types.ts
export interface Activity {
  id: number
  title: string
  cover_url?: string
  location?: string
  location_name?: string
  location_city?: string
  start_time: string
  end_time: string
  status: string
  // ... 更多字段
}
```

**建议方案**:
创建共享类型定义库：

```typescript
// packages/types/src/activity.ts
export interface BaseActivity {
  id: number
  title: string
  location: string
  location_name?: string
  start_time: string
  end_time: string
}

export interface ActivityDetail extends BaseActivity {
  cover_url?: string
  location_city?: string
  status: ActivityStatus
  description?: string
  agenda?: AgendaItem[]
  hotels?: Hotel[]
}

export interface ActivityInfo extends BaseActivity {
  // 仅用于报名页面的简化信息
}
```

**工作量**: 16 小时

---

## 3. 性能问题

### 3.1 重复渲染问题

#### P1: 缺少 `useMemo` 和 `useCallback` 优化

**统计数据**:
```
useState/useEffect: 100+ 次使用
useMemo: 0 次使用
useCallback: 52 次使用（仅在部分组件）
```

**典型案例**:

**案例1**: `/frontend/app/src/pages/activity-detail/index.tsx:332-495`
```typescript
// ❌ 不良实践：每次渲染都创建新的数组对象
const DEFAULT_AGENDA = [
  { id: 1, title: '开幕仪式', items: [...] },
  { id: 2, title: '主旨报告', items: [...] },
  // ... 150+ 行的静态数据
]

// ✅ 推荐做法：移到组件外部或使用 useMemo
const DEFAULT_AGENDA = useMemo(() => [
  // ... 数据
], [])
```

**案例2**: `/frontend/app/src/pages/signup/index.tsx:83-119`
```typescript
// ❌ 不良实践：每次渲染都创建新函数
const validateStep = (): boolean => {
  const step = STEPS[currentStep]
  // ... 校验逻辑
}

// ✅ 推荐做法
const validateStep = useCallback((): boolean => {
  const step = STEPS[currentStep]
  // ... 校验逻辑
}, [currentStep, formData])
```

**影响范围**:
- 组件不必要的重新渲染
- 性能下降，特别是在低端设备

**建议方案**:
1. 对于大型数据（如 DEFAULT_AGENDA, DEFAULT_HOTELS），使用 `useMemo` 或移至组件外部
2. 对于传递给子组件的函数，使用 `useCallback` 包裹
3. 使用 React DevTools Profiler 检测渲染性能瓶颈

**工作量**: 12 小时

---

### 3.2 列表渲染优化问题

#### P2: 长列表未使用虚拟滚动

**问题描述**:
`/frontend/app/src/pages/activity-detail/index.tsx` 中的议程列表可能包含大量议程项，但未使用虚拟滚动优化。

**影响范围**: 当议程超过 100 项时，渲染性能显著下降

**建议方案**:
```typescript
import VirtualList from '@tarojs/components/virtual-list'

const AgendaTab = ({ agenda }) => {
  return (
    <VirtualList
      height={600}
      itemData={agenda}
      itemCount={agenda.length}
      itemSize={80}
      width="100%"
    >
      {({ index, style }) => (
        <View style={style}>
          <AgendaItemCard item={agenda[index]} />
        </View>
      )}
    </VirtualList>
  )
}
```

**工作量**: 6 小时

---

### 3.3 资源加载优化

#### P2: 图片未实现懒加载

**问题描述**:
活动列表、酒店列表等场景中的图片未实现懒加载，影响首屏加载速度。

**建议方案**:
```typescript
import { Image } from '@tarojs/components'

// 使用 Taro 的 lazyLoad 属性
<Image
  src={activity.cover_url}
  mode="aspectFill"
  lazyLoad
  className="cover-image"
/>
```

**工作量**: 2 小时

---

### 3.4 网络请求优化

#### P2: 缺少请求缓存机制

**问题描述**:
`/frontend/app/src/services/activities.ts` 中的活动详情请求未实现缓存，用户多次访问同一活动时会重复请求。

**建议方案**:
```typescript
import { useMemo } from 'react'

// 使用 SWR 或 React Query 实现请求缓存
import useSWR from 'swr'

export const useActivityDetail = (activityId: number) => {
  const { data, error, isLoading } = useSWR(
    `/activities/${activityId}`,
    fetchActivityDetail,
    {
      revalidateOnFocus: false,
      dedupingInterval: 60000, // 60秒内不重复请求
    }
  )

  return { activity: data, error, isLoading }
}
```

**工作量**: 8 小时

---

## 4. 可维护性问题

### 4.1 注释与文档

#### P2: 注释覆盖率低

**统计数据**:
- 核心业务逻辑文件（如 `SignupService`）：约 30% 代码有注释
- UI 组件文件：约 10% 代码有注释
- 工具函数：约 5% 代码有注释

**典型案例**:
`/backend/app/services/signups.py:197-246` 中的 `_auto_award_on_approval` 方法包含复杂的授勋逻辑，但仅有简单注释。

**建议方案**:
```python
def _auto_award_on_approval(self, signup: Signup) -> None:
    """
    报名审核通过后自动授予徽章

    实现两种授勋策略：
    1. 规则引擎评估（可选）：通过 BadgeRuleService 评估所有激活的规则
    2. 兜底逻辑（向后兼容）：基于环境变量的首次/多次参会自动授勋

    授勋规则：
    - 首次参会：如果用户没有其他已通过的报名，授予 first_attendance 徽章
    - 多次参会：如果用户已通过的报名数量 >= threshold，授予 repeat_attendance 徽章

    Args:
        signup: 已审核通过的报名记录

    Returns:
        None

    Note:
        - 规则评估失败不影响兜底逻辑
        - 徽章授予失败（如徽章不存在）会被捕获并忽略
    """
    # ... 实现
```

**工作量**: 20 小时（全项目）

---

### 4.2 魔法数字与硬编码

#### P2: 大量魔法数字

**典型案例**:

**案例1**: `/frontend/app/src/pages/activity-detail/index.tsx:409`
```typescript
// ❌ 不良实践
const recent_signups = await recentSignups(activityId, { since_hours: 24, limit: 3 })

// ✅ 推荐做法
const RECENT_SIGNUPS_CONFIG = {
  sinceHours: 24,
  limit: 3,
} as const

const recent_signups = await recentSignups(activityId, RECENT_SIGNUPS_CONFIG)
```

**案例2**: `/frontend/app/src/pages/signup/index.tsx:53`
```typescript
// ❌ 不良实践
setStatusBarHeight(sysInfo.statusBarHeight || 44)

// ✅ 推荐做法
const DEFAULT_STATUS_BAR_HEIGHT = 44

setStatusBarHeight(sysInfo.statusBarHeight || DEFAULT_STATUS_BAR_HEIGHT)
```

**建议方案**:
创建常量配置文件：

```typescript
// constants/ui.ts
export const UI_CONSTANTS = {
  STATUS_BAR_HEIGHT: 44,
  SAFE_AREA_BOTTOM: 34,
  TAB_BAR_HEIGHT: 50,
} as const

// constants/business.ts
export const BUSINESS_CONSTANTS = {
  RECENT_SIGNUPS_HOURS: 24,
  RECENT_SIGNUPS_LIMIT: 3,
  MAX_COMPANIONS: 5,
} as const
```

**工作量**: 8 小时

---

### 4.3 配置管理

#### P3: 环境配置混乱

**问题描述**:
`/frontend/app/src/services/http.ts:4-8` 中的 baseURL 配置逻辑复杂：

```typescript
const baseURL =
  (typeof process !== 'undefined' &&
    process.env &&
    (process.env.TARO_APP_API_BASE || process.env.API_BASE_URL)) ||
  'http://localhost:8000/api/v1'
```

**建议方案**:
```typescript
// config/env.ts
const ENV_CONFIG = {
  development: {
    apiBaseUrl: 'http://localhost:8000/api/v1',
    enableMock: true,
  },
  production: {
    apiBaseUrl: 'https://api.example.com/api/v1',
    enableMock: false,
  },
} as const

export const getEnvConfig = () => {
  const env = process.env.NODE_ENV || 'development'
  return ENV_CONFIG[env]
}

// services/http.ts
import { getEnvConfig } from '../config/env'

const config = getEnvConfig()
export const api = axios.create({
  baseURL: config.apiBaseUrl,
  timeout: 15000
})
```

**工作量**: 4 小时

---

### 4.4 代码重复

#### P2: 议程数据重复定义

**问题描述**:
`/frontend/app/src/pages/activity-detail/index.tsx` 中定义了两套议程数据：
- `DEFAULT_AGENDA` (32-152行)
- `DEFAULT_MULTI_DAY_AGENDA` (154-414行)

大量重复的议程项结构。

**建议方案**:
```typescript
// mock/agendaData.ts
export const createAgendaItem = (config: AgendaItemConfig): AgendaItem => ({
  id: config.id,
  time_start: config.time_start,
  time_end: config.time_end,
  type: config.type || 'speech',
  title: config.title,
  speaker: config.speaker,
  location: config.location,
})

export const SINGLE_DAY_AGENDA = [
  createAgendaItem({ id: 11, time_start: '09:00', ... }),
  // ...
]

export const MULTI_DAY_AGENDA = [
  {
    date: '2025-11-12',
    groups: [
      {
        items: SINGLE_DAY_AGENDA.slice(0, 3), // 复用单天数据
      },
    ],
  },
]
```

**工作量**: 6 小时

---

### 4.5 控制台日志

#### P3: 生产环境仍包含调试日志

**统计数据**:
```
console.log: 4 处
console.warn: 0 处
console.error: 11 处（合理使用）
```

**建议方案**:
```typescript
// utils/logger.ts
export const logger = {
  log: (...args: any[]) => {
    if (process.env.NODE_ENV !== 'production') {
      console.log(...args)
    }
  },
  error: (...args: any[]) => {
    console.error(...args)
    // 可选：上报到监控平台
  },
  warn: (...args: any[]) => {
    if (process.env.NODE_ENV !== 'production') {
      console.warn(...args)
    }
  },
}

// 替换所有 console.log 为 logger.log
```

**工作量**: 2 小时

---

## 5. 安全问题

### 5.1 输入校验

#### ✅ 良好实践：前端输入校验完善

**评估结果**:
- `/frontend/app/src/pages/signup/index.tsx:83-119` 实现了完整的表单校验
- 使用了正则表达式校验手机号和邮箱格式
- 参数传递前进行了严格校验

**示例**:
```typescript
if (!name.trim()) {
  Taro.showToast({ title: '请输入姓名', icon: 'none' })
  return false
}
if (!phone.trim() || !VALIDATION_RULES.phone.test(phone)) {
  Taro.showToast({ title: '请输入正确的手机号码', icon: 'none' })
  return false
}
```

---

### 5.2 XSS 防护

#### ✅ 良好实践：未发现 `dangerouslySetInnerHTML` 使用

**评估结果**:
全局搜索未发现任何 `dangerouslySetInnerHTML` 的使用，所有用户输入都经过 React 的自动转义。

---

### 5.3 身份认证与授权

#### P1: JWT Token 无刷新机制

**问题描述**:
`/frontend/app/src/services/http.ts` 中的 token 处理缺少刷新逻辑，token 过期后用户体验不佳。

**建议方案**:
```typescript
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config

    // Token 过期处理
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true

      try {
        const refreshToken = Taro.getStorageSync('refresh_token')
        const response = await axios.post('/auth/refresh', { refreshToken })
        const { accessToken } = response.data

        Taro.setStorageSync('access_token', accessToken)
        originalRequest.headers['Authorization'] = `Bearer ${accessToken}`

        return api(originalRequest)
      } catch (refreshError) {
        // Refresh token 也过期，跳转登录
        Taro.navigateTo({ url: '/pages/login/index' })
        return Promise.reject(refreshError)
      }
    }

    const message = error?.response?.data?.detail || '请求失败，请稍后重试'
    Taro.showToast({ title: message, icon: 'none' })
    return Promise.reject(error)
  }
)
```

**工作量**: 8 小时

---

### 5.4 敏感信息处理

#### P2: 配置文件可能泄露敏感信息

**问题描述**:
`/backend/app/core/config.py` 中的敏感信息（如 `secret_key`, `wechat_secret`）依赖环境变量，但未强制校验。

**建议方案**:
```python
class Settings(BaseSettings):
    app_name: str = "event-signup"
    environment: str = "development"
    database_url: str  # 必填
    secret_key: str  # 必填
    wechat_appid: str | None = None
    wechat_secret: str | None = None

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        # 生产环境强制校验
        if self.environment == "production":
            if not self.secret_key or len(self.secret_key) < 32:
                raise ValueError("Production environment requires a strong secret_key (>= 32 chars)")
            if self.wechat_mock_enabled:
                raise ValueError("Production environment cannot use wechat_mock_enabled")
```

**工作量**: 4 小时

---

## 6. 测试覆盖问题

### 6.1 单元测试覆盖率

#### P0: 测试覆盖率极低

**统计数据**:
```
后端测试: 仅有 1 个测试文件（test_health.py）
前端测试: 无任何测试文件（仅 node_modules 中的依赖包测试）
```

**影响范围**:
- 代码重构风险极高
- 缺少回归测试保障
- Bug 修复可能引入新问题

**建议方案**:

**阶段1: 核心业务逻辑测试 (P0)**

```python
# backend/tests/services/test_signups.py
import pytest
from app.services.signups import SignupService
from app.models.enums import SignupStatus

def test_signup_creation(db_session, mock_user, mock_activity):
    service = SignupService(db_session)
    payload = SignupCreate(
        activity_id=mock_activity.id,
        answers=[
            {"field_id": 1, "value_text": "张三"},
            {"field_id": 2, "value_text": "13800138000"},
        ]
    )

    result = service.create(payload, mock_user.id)

    assert result.status == SignupStatus.PENDING
    assert result.user_id == mock_user.id
    assert result.activity_id == mock_activity.id

def test_signup_approval(db_session, mock_signup, mock_admin):
    service = SignupService(db_session)

    result = service.review(
        mock_signup.id,
        mock_admin,
        SignupReviewRequest(action="approve", message="通过")
    )

    assert result.status == SignupStatus.APPROVED
    assert result.reviewed_by_admin_id == mock_admin.id
    assert result.approved_at is not None
```

```typescript
// frontend/app/src/pages/signup/__tests__/index.test.tsx
import { render, fireEvent, waitFor } from '@testing-library/react'
import SignupPage from '../index'

describe('SignupPage', () => {
  it('should validate required fields', async () => {
    const { getByText, getByPlaceholderText } = render(<SignupPage />)

    const nextButton = getByText('下一步')
    fireEvent.click(nextButton)

    await waitFor(() => {
      expect(getByText('请输入姓名')).toBeInTheDocument()
    })
  })

  it('should submit form successfully', async () => {
    const { getByText, getByPlaceholderText } = render(<SignupPage />)

    fireEvent.change(getByPlaceholderText('请输入姓名'), { target: { value: '张三' } })
    fireEvent.change(getByPlaceholderText('请输入手机号'), { target: { value: '13800138000' } })
    // ... 填写其他字段

    const submitButton = getByText('提交报名')
    fireEvent.click(submitButton)

    await waitFor(() => {
      expect(getByText('报名成功')).toBeInTheDocument()
    })
  })
})
```

**工作量**: 40 小时（核心模块）

**阶段2: 集成测试 (P1)**

```python
# backend/tests/api/test_signups_api.py
from fastapi.testclient import TestClient

def test_create_signup_endpoint(client: TestClient, auth_headers):
    response = client.post(
        "/api/v1/signups",
        json={
            "activity_id": 1,
            "answers": [
                {"field_id": 1, "value_text": "张三"},
            ]
        },
        headers=auth_headers
    )

    assert response.status_code == 201
    data = response.json()
    assert data["status"] == "pending"
    assert data["activity_id"] == 1
```

**工作量**: 30 小时

**阶段3: E2E 测试 (P2)**

```typescript
// e2e/signup-flow.spec.ts
import { test, expect } from '@playwright/test'

test('complete signup flow', async ({ page }) => {
  await page.goto('/pages/activity-detail/index?id=1')
  await page.click('text=立即报名')

  // 填写个人信息
  await page.fill('[placeholder="请输入姓名"]', '张三')
  await page.fill('[placeholder="请输入手机号"]', '13800138000')
  await page.click('text=下一步')

  // 填写缴费信息
  await page.fill('[placeholder="请输入发票抬头"]', '某某公司')
  await page.fill('[placeholder="请输入邮箱"]', 'test@example.com')
  await page.click('text=下一步')

  // 提交
  await page.click('text=提交报名')

  // 验证成功页面
  await expect(page.locator('text=报名成功')).toBeVisible()
})
```

**工作量**: 24 小时

---

### 6.2 测试基础设施缺失

#### P1: 缺少测试配置

**建议方案**:

**后端测试配置**:
```toml
# pyproject.toml
[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = ["test_*.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]
addopts = [
    "--cov=app",
    "--cov-report=html",
    "--cov-report=term-missing",
    "--cov-fail-under=80",
]

[tool.coverage.run]
omit = [
    "*/tests/*",
    "*/migrations/*",
    "*/__init__.py",
]
```

**前端测试配置**:
```javascript
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/tests/setup.ts'],
  moduleNameMapper: {
    '\\.(css|less|scss|sass)$': 'identity-obj-proxy',
  },
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/*.stories.tsx',
  ],
  coverageThresholds: {
    global: {
      branches: 70,
      functions: 70,
      lines: 70,
      statements: 70,
    },
  },
}
```

**工作量**: 8 小时

---

## 技术债务优先级路线图

### P0 - 紧急修复（1-2周内完成）

| 编号 | 问题 | 影响 | 工作量 | 负责人 |
|------|------|------|--------|--------|
| P0-1 | 测试覆盖率极低 | 重构风险极高 | 40h | 待定 |
| P0-2 | 核心业务逻辑单元测试 | 功能稳定性 | 40h | 待定 |
| P0-3 | 集成测试基础设施 | 质量保障 | 30h | 待定 |

**预计总工时**: 110 小时（约 3 人周）

---

### P1 - 高优先级（1个月内完成）

| 编号 | 问题 | 影响 | 工作量 | 负责人 |
|------|------|------|--------|--------|
| P1-1 | `any` 类型滥用 | 类型安全 | 24h | 待定 |
| P1-2 | 缺少共享类型定义库 | 代码一致性 | 16h | 待定 |
| P1-3 | 缺少性能优化（useMemo/useCallback） | 用户体验 | 12h | 待定 |
| P1-4 | JWT Token 无刷新机制 | 用户体验 | 8h | 待定 |
| P1-5 | 服务层依赖过多 | 可测试性 | 12h | 待定 |
| P1-6 | 缺少请求缓存机制 | 性能 | 8h | 待定 |
| P1-7 | 测试配置基础设施 | 质量保障 | 8h | 待定 |
| P1-8 | E2E 测试 | 回归测试 | 24h | 待定 |

**预计总工时**: 112 小时（约 3 人周）

---

### P2 - 中优先级（2-3个月内完成）

| 编号 | 问题 | 影响 | 工作量 | 负责人 |
|------|------|------|--------|--------|
| P2-1 | 活动卡片组件重复定义 | 维护成本 | 4h | 待定 |
| P2-2 | 表单字段渲染器重复逻辑 | 代码重复 | 6h | 待定 |
| P2-3 | 业务逻辑与UI组件耦合 | 可测试性 | 8h | 待定 |
| P2-4 | 注释覆盖率低 | 可维护性 | 20h | 待定 |
| P2-5 | 魔法数字与硬编码 | 可读性 | 8h | 待定 |
| P2-6 | 议程数据重复定义 | 代码重复 | 6h | 待定 |
| P2-7 | 长列表未使用虚拟滚动 | 性能 | 6h | 待定 |
| P2-8 | 图片未实现懒加载 | 性能 | 2h | 待定 |
| P2-9 | 配置文件敏感信息校验 | 安全性 | 4h | 待定 |
| P2-10 | 缺少错误监控 | 运维 | 8h | 待定 |
| P2-11 | 缺少性能监控 | 运维 | 8h | 待定 |
| P2-12 | API 接口文档不完整 | 协作效率 | 12h | 待定 |

**预计总工时**: 92 小时（约 2.5 人周）

---

### P3 - 低优先级（有时间再优化）

| 编号 | 问题 | 影响 | 工作量 | 负责人 |
|------|------|------|--------|--------|
| P3-1 | 环境配置混乱 | 可维护性 | 4h | 待定 |
| P3-2 | 生产环境包含调试日志 | 安全性 | 2h | 待定 |
| P3-3 | 缺少代码规范检查 | 代码质量 | 8h | 待定 |
| P3-4 | 缺少自动化部署 | 运维效率 | 16h | 待定 |
| P3-5 | 缺少代码审查流程 | 代码质量 | 8h | 待定 |
| P3-6 | 缺少性能预算 | 性能 | 4h | 待定 |

**预计总工时**: 42 小时（约 1 人周）

---

## 总结与建议

### 技术债务总览

```
总计技术债务项: 29 项
  - P0 (紧急): 3 项，110 工时
  - P1 (高优): 8 项，112 工时
  - P2 (中优): 12 项，92 工时
  - P3 (低优): 6 项，42 工时

总工时估算: 356 小时（约 9 人周）
```

### 优先级建议

#### 第一阶段（第1-2周）：P0 紧急修复
- **核心目标**: 建立测试基础设施，保障代码质量
- **关键行动**:
  1. 为核心业务逻辑（SignupService、ActivityService）编写单元测试
  2. 搭建测试基础设施（pytest、jest 配置）
  3. 建立 CI/CD 流程中的测试门禁

#### 第二阶段（第3-6周）：P1 高优修复
- **核心目标**: 提升代码质量和用户体验
- **关键行动**:
  1. 修复 TypeScript `any` 类型滥用问题
  2. 添加性能优化（useMemo、useCallback）
  3. 实现 JWT Token 刷新机制
  4. 建立共享类型定义库

#### 第三阶段（第7-12周）：P2 中优修复
- **核心目标**: 重构重复代码，提升可维护性
- **关键行动**:
  1. 抽取重复组件为共享组件
  2. 解耦业务逻辑与 UI 组件
  3. 完善代码注释和文档

#### 第四阶段（有时间时）：P3 低优优化
- **核心目标**: 完善开发流程和工具链
- **关键行动**:
  1. 统一环境配置管理
  2. 建立代码审查流程
  3. 添加性能监控和错误追踪

### 关键指标

建议设立以下关键指标来衡量技术债务清理进度：

| 指标 | 当前值 | 目标值 | 时间线 |
|------|--------|--------|--------|
| 测试覆盖率 | < 5% | 70% | 3 个月 |
| TypeScript `any` 使用次数 | 150+ | < 20 | 2 个月 |
| 代码重复率 | 未知 | < 5% | 3 个月 |
| 平均页面加载时间 | 未知 | < 2s | 2 个月 |
| 关键业务逻辑注释覆盖率 | 30% | 80% | 3 个月 |

### 长期建议

1. **建立技术债务管理流程**
   - 每季度进行技术债务盘点
   - 每个迭代预留 20% 时间用于清理技术债务

2. **强化代码质量门禁**
   - Pull Request 必须包含测试
   - 测试覆盖率不得低于当前基线
   - 禁止新增 `any` 类型（除非有明确注释说明原因）

3. **提升团队技术能力**
   - 定期进行代码审查培训
   - 建立最佳实践知识库
   - 分享技术债务清理经验

---

**报告结束**

*本报告由 Claude Code 自动生成，建议定期更新以跟踪技术债务清理进度。*
